---
title: "Homework 5"
author: Amanda Warnock
output: github_document
---

This is my solution to HW5.

```{r}
library(tidyverse)
library(rvest)
library(ggplot2)
library(data.table)
knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.color = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_color_discrete = scale_color_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```


## Problem 1

Read in the data.
```{r}
homicide_df = 
  read_csv("./data/homicide-data.csv") %>% 
  mutate(
   city_state = str_c(city, state, sep = "_"),
   resolved = case_when(
     disposition == "Closed without arrest" ~ "unsolved",
     disposition == "Open/No arrest"        ~ "unsolved",
     disposition == "Closed by arrest"      ~ "solved"
   ) 
  ) %>% 
  select(city_state, resolved) %>% 
  filter(city_state != "Tulsa_AL")
```

Let's look at this a bit.

```{r}
aggregate_df = 
homicide_df %>% 
  group_by(city_state) %>% 
  summarize(
    hom_total = n(),
    hom_unsolved = sum(resolved == "unsolved")
  )
```

Can I do a prop test for a single city?

```{r}
prop.test(
  aggregate_df %>% filter(city_state == "Baltimore_MD") %>% pull(hom_unsolved), 
  aggregate_df %>% filter(city_state == "Baltimore_MD") %>% pull(hom_total)) %>% 
  broom::tidy()
```

Try to iterate .....

```{r}
results_df = 
aggregate_df %>% 
  mutate(
    prop_test = map2(.x = hom_unsolved, .y = hom_total, ~prop.test(x = .x, n = .y)),
    tidy_test = map(.x = prop_test, ~broom::tidy(.x))
  ) %>% 
  select(-prop_test) %>% 
  unnest(tidy_test) %>% 
  select(city_state, estimate, conf.low, conf.high)
```

```{r}
results_df %>% 
  mutate(city_state = fct_reorder(city_state, estimate)) %>% 
  ggplot(aes(x = city_state, y = estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) 
```

## Problem 2

Import the 20 files, clean, and tidy.

```{r}
path_df = 
  tibble(
    path = list.files("./lddata")
  ) %>% 
  mutate(
    path = str_c("lddata/", path),
    path_names = path,
    data = map(path, read_csv)
    ) %>% 
  separate(col = path_names, into = c("path_1", "path_2"), sep = 7, remove = T) %>% 
  separate(col = path_2, into = c("arm", "ID"), sep = 3) %>% 
  separate(col = ID, into = c("underscore", "ID"), sep = 1, remove = T) %>% 
  separate(col = ID, into = c("ID", "csv"), sep = 2, remove = T) %>% 
  select(-path_1, -underscore, -csv) %>% 
  mutate(
    arm = str_replace(arm, "con", "Control"),
    arm = str_replace(arm, "exp", "Experiment")) %>% 
  unnest(data) %>% 
  pivot_longer(
    week_1:week_8,
    names_to = "week", 
    values_to = "observation"
  ) 
```

Make a spaghetti plot showing observations 
```{r}
path_plot = 
  path_df %>% 
  unite("Arm_ID", arm:ID, sep = "_", remove = FALSE) %>% 
  ggplot(aes(x = week, y = observation, group = Arm_ID, color = arm)) +
  geom_line() +
  labs(title = "Observations per Subject Over Time")

path_plot
```

This plot shows that overall, the observations for the subjects in the experiment group were higher than the observations for the control group. Though the starting observations for the subjects were mixed at week 1, all observations for the experiment group were higher than all observations for the control group at week 8. 

## Problem 3

simulate sample from normal distribution of 30 w sd of 5. change mean from 0 to 1, 2, 3, 4, 5. for each mean, generate 5000 datasets. Not exporting mean and sd - exporting the results of the ttest of whether the mean = 0. reject or fail to reject 5% of time, etc. point: see what happens as you move from 0 to 5. 
make plot of estimated mean when true mean is 0-5, filter for when p <0.05 and then compute mean. start with simmean and sd function we wrote in class and modify. plots are summaries of that p values and estimates based on whether thigns are significant. always testing null hyp that mean = 0. 
```{r}
sim_ttest = function(n, mu = 0, sigma = 5) {
  
  sim_data = tibble(
    x = rnorm(n = 30, mean = mu, sd = sigma),
  )
  
    ttest=t.test(sim_data, mu=0, sd=5)
    ttest[['p.value']]
    ttest[['estimate']]
    
  sim_results = tibble(
     pvalue = ttest[['p.value']],
     mean = ttest[['estimate']]
  )

}

output = vector("list", 5000)

for (i in 1:5000) {
  output[[i]] = sim_ttest(30) 
}
sim_results = bind_rows(output)
```

Testing the simulation in rerun. 

```{r}
sim_results1 = 
  rerun(5000, sim_ttest(30, 1, 5)) %>% 
  bind_rows()
```

Simulating across multiple means. 

```{r}
m_list = 
  list(
    "n_0" = 0,
    "n_1" = 1,
    "n_2" = 2,
    "n_3" = 3,
    "n_4" = 4,
    "n_5" = 5,
    "n_6" = 6
  )

output = vector("list", length = 4)

for (i in 1:7) {
  ouput[[i]] = rerun(5000, sim_ttest, 30, m_list[[i]], 5) %>% 
    bind_rows
}
```




